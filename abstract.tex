\begin{abstract}
% eBPF has become the de-facto kernel extension mechanism in the Linux kernel
%   and have been leveraged extensively in domains of networking, system
%   debugging and event tracing, as well as, security.
% The core value proposition of eBPF is the unprecedented promise of safety
%   through its static verification scheme: the kernel performs symbolic
%   execution on the compiled eBPF bytecode to examine various safety properties.
% Despite its safety guarantees, the price of kernel verification of eBPF
%   programs is high.
% The restricted expressiveness of eBPF on loops or complex logic often leads to
%   splitting the program into small pieces, or limitation in functionality when
%   logic cannot be expressed.
% On the other hand, static verification is fundamentally limited in verifying
%   certain safety properties -- a verified eBPF program can still overflow
%   the kernel stack or hold the CPU for a long time.

Kernel extension is an essential component of modern operating systems.
In recent years, kernel extension has been increasingly leveraged in the domains
  of file systems, consensus protocols, key-value storage, and security, often
  in the form of large and complex programs.
The de-facto kernel extension mechanism in the Linux kernel is eBPF.
However, eBPF is contrained by its static verifier, which provides
  safety as its core value proposition but at the same time creates usability
  challenges, especially for the increasingly complex use cases.
%  makes it hard to
%  support the increasingly complex use cases due to limited expressiveness.
% The restriction of eBPF on loops or complex logic often leads to splitting the
%   program into small pieces, or limitation in functionality when logic cannot
%   be expressed.
Developers are often forced to heavily massage their code -- splitting the
  program into small pieces, inlining functions, and even directly writing
  eBPF byte codes, in order to pass the verifier.
% On the other hand, static verification is fundamentally limited in verifying
%   certain safety properties -- a verified eBPF program can still overflow
%   the kernel stack or hold the CPU for a long time.
At the core of the problem is a large gap between the programmer and the
  verifier.

In this paper, we make the observation that the enhanced usuability and the
  needed safety properties can be obtained from a safe language like Rust
  without the verifier.
We design and implement a new Rust-based kernel extension abstraction:
  {\em Rex}, which are safe Rust programs that run in
  the place of verified eBPF programs.
% The use of Rust achieves both Turing-Completeness and runtime-safety.
Our Rust layer provides a \textit{safe} program interface for kernel extension
  programs and runtime safety mechanisms that ensures stack protection, timely
  termination, and exception handling.
We implement several state of the art eBPF programs with comparable
  performance to JITed eBPF programs, demonstrating there is no need to split
  programs or limit their processing data size.

\end{abstract}
