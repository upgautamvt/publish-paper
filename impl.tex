\section{Design and Implementation}

% \subsection{Design goal}

%\begin{itemize}
%     \item Safety
%         \begin{itemize}
%             \item Same level of safety as eBPF
%             \item Memory safety
%             \item Control-flow soundness
%             \item Resource management
%             \item Program termination
%         \end{itemize}
%     \item Expressiveness
%         \begin{itemize}
%             \item Support more complicated/advanced programs
%             \item Longer programs
%             \item Unbounded loops
%         \end{itemize}
%     \item An important note: we want expressiveness w/o impairing safety (e.g.
%         allow unbounded loop while ensuring termination)
% \end{itemize}

% \subsection{Overview}
% \begin{itemize}
%     \item Brings out the Rust based approach (use Jiyuan's property-oriented
%         argument: We want these properties, and Rust happens to provide these)
%     \item Infrastructure (Need a figure similar to Fig. 5 from HotOS paper)
% \end{itemize}

\subsection{\projname{} kernel crate}
\begin{itemize}
    \item overall structure: program type, kernel binding generation, wrapper
        interface around binding.
    \item context conversion
    \item kernel helper and symbol bindings (dynamic linking scheme)
    \item kconfig-based conditional compilation
    \item Map support
\end{itemize}

The \projname{} kernel crate is responsible for supporting interactions between
    kernel and \projname{} programs.
This library can be divided into support for different program types with
    intrefaces facing the kernel and the \projname{} program.
Each of the program type is defined as a Rust struct and with helpers defined
    as its methods.
This effectively implements access control on helper functions with respect to
    program types (e.g., a tracing program should not modify socket buffers
    through networking helper functions), which is also present in eBPF.
On the side of \projname{} program, the user defines a program object
    associated with a Rust function as the extension program and can invoke
    helper functions through the program object.
For the kernel interface, we create bindings for the needed kernel definitions
Specifically, we use Rust-bindgen~\cite{bindgen} to create bindings for kernel
    structure definitions and constants from kernel header files.
For required kernel symbols (e.g., kernel helper functions), the kernel crate
    creates a stub declaration for each symbol without using Rust-bindgen.
This is because certain kernel symbols -- especially all eBPF helper
    functions --  do not have a declaration in kernel header files.
The actual definition of the kernel symbols will be resolved when the program
    is loaded into the kernel (\S~\ref{impl:crate:symbol-resolv}).
The crate also has support for maps (\S~\ref{impl:crate:map}) and other
    miscellaneous utilities for the ease of programming (e.g. wrapping return
    code in \texttt{Result} to support monadic operations in Rust).

\subsubsection{Program context conversion}
Like eBPF, \projname{} programs take in a kernel-provided ``context'' as input
    argument.
The context is a pointer to a struct that contains information the program may
    need.
For the reason of keeping a stable interface and to hidden unneeded kernel
    data from the extension program, eBPF keeps a pair of context structs,
    where one of them is for user-written extension programs and the other one
    is the internal representation of the kernel.
The user-facing context is a subset of the associateed kernel
    representation.
When a eBPF program is loaded into the kernel, the verifier rewrites accesses
    to the user context to the corresponding field in the kernel context 
    through the verifier hook specific to the program type.
Rewriting the access also avoids the need of copying data and contructing a
    user context.

In \projname{}, the Rust compiler takes the place of the eBPF verifier and as
    a result there is no way to rewrite the access to the context the same
    way eBPF does.
We choose to take the advantage of the expressive Rust language features.
In particular, \projname{} defines a user-context struct that just wraps around
    the pointer to kernel context.
It implements accesses to the needed fields in the kernel context as methods of
    the user-context struct, which accesses the kernel struct internally.
Doing so effectively re-route accesses to the kernel struct.
At the same time, it also allows controlled access to the kernel context, in
    particular it easily prevents unwanted writes to the context, which may
    corrupt kernel data accidentally.

\subsubsection{Kernel symbol resolution}
\label{impl:crate:symbol-resolv}
The \projname{} kernel crate serves as an interface for the extension programs
    to interact with the kernel.
To accomplish this, the crate will need to access kernel symbols.
For example, invoking kernel helper functions requires knowing the kernel
    address of the target helper function symbol.
These kernel symbols includes not only BPF helper functions, but also other
    global and per-CPU variables.

Because \projname{} programs are compiled in userspace, the compiler does not
    have knowledge on any of the required kernel symbols.
One simple solution is to directly passing kernel symbols and their
    corresponding addresses to userspace (e.g. through \texttt{/proc/kallsyms})
However, this is in general considered a dangerous practice as it leaks kernel
    addresses to userspace.
At the same time, this solution is not robust against kernel layout changes
    (e.g. due to kernel rebuild) -- changes of a kernel symbol address requires
    a recompilation of the \projname{} program that uses it.

Our implementation defers the kernel symbol resolution to program load time,
    i.e. when the compiled \projname{} program is sent to the kernel.
At this point, the booted kernel always knows where the symbols are located,
    even after layout changes.
At the same time, the sensitive kernel addresses do not need to be leaked to
    userspace.

\projname{} implements this kernel symbol resolution scheme the same way
    dynamic linking works in userspace.
The \projname{} kernel crate creates stub declarations for the required kernel
    symbols.
During compilation, the compiler treats all kernel symbols as external and\
    generate relocation entries for these undefined symbols.
At load time, the loader library parses the executable, compiles a list of
    kernel sybmols that require resolution with their corresponding entries in
    the global offset table (GOT), and sends the information to the kernel.
The kernel then resolves the address for each symbol via the kallsyms subsystem
    and patches the GOT entries with the resolved addresses and allows programs
    to correctly referencing these kernel symbols.

\subsubsection{Kconfig-aware conditional compilation}
% kernel uses config-based conditional compilation
% certain functionalities may not be compiled in
% we also use conditional compilation in kernel crate
% read config from build script and pass to the compilation process
The fact that the Linux kernel employs conditional compilation extensively
    based on kernel configuration values implies that certain functionalities
    used by \projname{} programs may not be compiled in.
An example of this is the ability to override the return value of a function in
    Kprobe programs.
This is only available if the \texttt{CONFIG\_BPF\_KPROBE\_OVERRIDE} is
    enabled.
The \projname{} kernel crate utilizes the conditional compilation counterpart
    in Rust.
The build script of the crate parses the configuration of the kernel for which
    the program is built and send configuration values of interest to the
    compiler.
If a functionality does not have its associated configuration set, its support
    in the kernel crate will not be present, either.

\subsubsection{Supporting eBPF maps}
\label{impl:crate:map}

\subsection{Program load and attachment}
\begin{itemize}
    \item kernel loading code and attachment
    \item relocation fixups for maps and kernel symbols
    \item libiu
\end{itemize}

\subsection{Entry code generation}
\begin{itemize}
    \item LLVM pass
\end{itemize}

\subsection{Handle exceptional control flow}
\begin{itemize}
    \item kernel trampoline
\end{itemize}

\subsection{Stack overflow protection}
\begin{itemize}
    \item kernel vmapped, dedicated stack
    \item LLVM instrumentation
\end{itemize}

\subsection{program termination}
\begin{itemize}
    \item Need work
\end{itemize}
