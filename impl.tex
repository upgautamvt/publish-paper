\section{Design and Implementation}
\label{sec:impl}

\jinghao{\S~\ref{sec:impl}: How to make it work}

% \subsection{Design goal}

%\begin{itemize}
%     \item Safety
%         \begin{itemize}
%             \item Same level of safety as eBPF
%             \item Memory safety
%             \item Control-flow soundness
%             \item Resource management
%             \item Program termination
%         \end{itemize}
%     \item Expressiveness
%         \begin{itemize}
%             \item Support more complicated/advanced programs
%             \item Longer programs
%             \item Unbounded loops
%         \end{itemize}
%     \item An important note: we want expressiveness w/o impairing safety (e.g.
%         allow unbounded loop while ensuring termination)
% \end{itemize}

% \subsection{Overview}
% \begin{itemize}
%     \item Brings out the Rust based approach (use Jiyuan's property-oriented
%         argument: We want these properties, and Rust happens to provide these)
%     \item Infrastructure (Need a figure similar to Fig. 5 from HotOS paper)
% \end{itemize}

We now discuss the high-level mechanisms that we use to build various features in
    \projname{} and make it a practical kernel extension framework.
These include the following:
\begin{itemize}
    \item How the \projname{} kernel crate bridges programs and the kernel.
    \item How \projname{} programs are loaded and attached.
    \item How eBPF maps are supported in \projname{}.
    \item How is the entry of \projname{} implemented that allows kernel to
        execute them directly.
\end{itemize}

\subsection{\projname{} kernel crate}
% \begin{itemize}
%     \item overall structure: program type, kernel binding generation, wrapper
%         interface around binding.
%     \item context conversion
%     \item kernel helper and symbol bindings (dynamic linking scheme)
%     \item kconfig-based conditional compilation
%     \item Map support
% \end{itemize}

The \projname{} kernel crate is responsible for supporting interactions between
    kernel and \projname{} programs.
This library contains support for different program types with
    interfaces facing the kernel and the \projname{} program.
Each program type is defined as a Rust struct and with allowed helpers defined
    as its methods.
This effectively implements access control on helper functions with respect to
    program types (e.g., a tracing program should not modify socket buffers
    through networking helper functions), which is also present in eBPF.
The user defines a program object that is one of the program struct types and
    assoociates it with a Rust function as the extension program.
The extension function takes in the associated program object and the
    program-type-specific context from the kernel as arguments
    (\S~\ref{impl:ctx-converison}).
Inside the extension, developers can use Rust kernel bindings generated by the
    crate to access kernel structures (\S~\ref{impl:crate:binding}).
At the same time, helper functions allowed for the program type can be
    invoked through the program object, which is backed by kernel symbols
    (\S~\ref{impl:crate:symbol-resolv}).

% The crate also has support for maps (\S~\ref{impl:map}) and other
%     miscellaneous utilities for the ease of programming (e.g. wrapping return
%     code in \texttt{Result} to support monadic operations in Rust).

\subsubsection{Supplying program context}
\label{impl:ctx-converison}
% Like eBPF, \projname{}
Extension programs take in a kernel-provided ``context'' as input argument.
The context is a pointer to a struct that contains information the program may
    need.
The current eBPF keeps a pair of context struct definitions for certain program
    types, where one of them is exposed to extension programs and the other one
    is the internal data structure in the kernel.
The extension-facing definition is generally a subset of the associated kernel
    internal definition.
This is done for the reason of keeping a stable interface and hidding unneeded
    kernel data from the extension programs.
When a eBPF program is loaded into the kernel, the verifier rewrites accesses
    to the user context to the corresponding field in the kernel context
    through the verifier hook specific to the program type.
Rewriting the access also avoids the need of copying data and contructing a
    user context.

% In \projname{}, the Rust compiler takes the place of the eBPF verifier and as
%     a result there is no way to rewrite the access to the context the same
%     way eBPF does.
In \projname{} the removal of the verifier means it cannot rewrite the access
    to the context the same way eBPF does.
Instead, \projname{} take the advantage of the expressive Rust language
    features.
In particular, \projname{} exports to the extension programs a struct that just
    wraps around the pointer to kernel context.
It implements accesses to the needed fields in the kernel context as safe Rust
    methods of this struct, which accesses the kernel struct internally.
Doing so effectively re-route accesses to the kernel struct.
At the same time, it also allows controlled access to the kernel context, in
    particular, it prevents unwanted writes to the context, which may
    corrupt kernel data accidentally.

\subsubsection{Creating Rust bindings of kernel structs}
\label{impl:crate:binding}
Extension programs rely heavily on the kernel data structure definitions.
A tracing program may want to obtain some information from the kernel
    \texttt{task\_struct}, while a networking program needs to know the layout
    of network headers.
In eBPF, the need can be easily full-filled by including the corresponding
    kernel header files, as most of the time the program is implemented in C
    and compiled to eBPF bytecode.

The problem is more complicated in \projname{}, as it selects Rust as the
    programming language, which cannot directly work with kernel headers.
% As a solution, \projname{} creates Rust bindings for the needed kernel
%     definitions.
As a solution, \projname{} uses Rust-bindgen~\cite{bindgen} to create Rust
    bindings for kernel structure definitions and constants from kernel header
    files.
\projname{} integrates the binding generation into program compilation so that
    the bindings are automatically generated for the target kernel during
    build.
The generated Rust binding forms part of the kernel crate and can be imported
    into \projname{} programs like other kernel crate exports.

\subsubsection{Supporting kernel helper functions}
\label{impl:crate:symbol-resolv}
Kernel extensions utilizes kernel helper functions for perform more advanced
    operations.
eBPF uses kernel helpers as both a way to interact with the kernel and to
    complement its limitation on expressiveness.
\projname{}, on the other hand, only uses helpers for kernel interaction, since
    Rust is expressive enough that it does not need additional helper functions.

\projname{} uses the existing eBPF helper interface and implements on top of
    it a Rust wrapping layer.
This wrapping layer serves to hide the unsafe C helper interface and provide a
    new interface that \projname{} programs can safely use.
For example, the eBPF map lookup function returns a pointer to the map value
    of type \texttt{*mut T}, the \projname{} wrapping layer wraps the pointer
    into a Rust \texttt{Option} type: \texttt{Option<\&mut T>}, which allows
    \projname{} programs to safely access the object without worrying about
    deferencing a null pointer.
%\jinghao{TODO: Show a helpr example}

In eBPF, most of the helper calls are direct function calls, however, a few of
    them are further optimized during verification and JITing.
Helper functions in \projname{} do not have the same load time optimization,
    and at the same time the kernel crate wraps the unsafe kernel helpers with
    a safe Rust interface, which could incur further overhead.
We further evaluate the impact in \S~\ref{eval:inline}.

% For required kernel symbols (e.g., kernel helper functions), the kernel crate
%     creates a stub declaration for each symbol without using Rust-bindgen.
% This is because certain kernel symbols -- especially all eBPF helper
%     functions --  do not have a declaration in kernel header files.
% The actual definition of the kernel symbols will be resolved when the program
%     is loaded into the kernel (\S~\ref{impl:crate:symbol-resolv}).

% The \projname{} kernel crate serves as an interface for the extension programs
%     to interact with the kernel.
% To accomplish this, the crate will need to access kernel symbols.
To reuse the existing kernel helper interface, the crate will need to access
    kernel symbols.
At the same time, the crate itself may also need to access certain kernel
    symbols for internal house keeping operations (e.g. cleanups as in
    \S~\ref{principle:eh})
% For example, invoking kernel helper functions requires knowing the kernel
%     address of the target helper function symbol.
% These kernel symbols includes not only BPF helper functions, but also other
%     global and per-CPU variables.
Because \projname{} programs are compiled in userspace, the compiler does not
    have knowledge on any of the required kernel symbols.
% One simple solution is to directly passing kernel symbols and their
%     corresponding addresses to userspace (e.g. through \texttt{/proc/kallsyms})
% However, this is in general considered a dangerous practice as it leaks kernel
%     addresses to userspace.
% At the same time, this solution is not robust against kernel layout changes
%     (e.g. due to kernel rebuild) -- changes of a kernel symbol address requires
%     a recompilation of the \projname{} program that uses it.

\projname{} therefore defers the kernel symbol resolution to program load time,
    i.e. when the compiled \projname{} program is sent to the kernel.
At this point, the booted kernel always knows where the symbols are located,
    even after layout changes.
At the same time, the sensitive kernel addresses do not need to be leaked to
    userspace.

\projname{} implements this kernel symbol resolution scheme the same way
    dynamic linking works in userspace.
The \projname{} kernel crate creates stub declarations for the required kernel
    symbols.
During compilation, the compiler treats all kernel symbols as external and\
    generate relocation entries for these undefined symbols.
At load time, the loader library parses the executable, compiles a list of
    kernel sybmols that require resolution with their corresponding entries in
    the global offset table (GOT), and sends the information to the kernel.
The kernel then resolves the address for each symbol via the kallsyms subsystem
    and patches the GOT entries with the resolved addresses and allows programs
    to correctly referencing these kernel symbols.

\subsubsection{Kconfig-aware conditional compilation}
% kernel uses config-based conditional compilation
% certain functionalities may not be compiled in
% we also use conditional compilation in kernel crate
% read config from build script and pass to the compilation process
The fact that the Linux kernel employs conditional compilation extensively
    based on kernel configuration values implies that certain functionalities
    used by \projname{} programs may not be compiled in.
An example of this is the ability to override the return value of a function in
    Kprobe programs.
This is only available if the \texttt{CONFIG\_BPF\_KPROBE\_OVERRIDE} is
    enabled.
The \projname{} kernel crate utilizes the conditional compilation counterpart
    in Rust.
The build script of the crate parses the configuration of the kernel for which
    the program is built and send configuration values of interest to the
    compiler.
If a functionality does not have its associated configuration set, its support
    in the kernel crate will not be present, either.

\subsection{Program load and attachment}
% \begin{itemize}
%     \item kernel loading code and attachment (w/ base program)
%     \item relocation fixups for maps and kernel symbols
%     \item libiu
% \end{itemize}
% Difference between eBPF and Rust programs
% - native code vs. byte code + JIT
% - no verifier to fixup relocations for maps and kernel symbols (e.g helpers)
% Implement kernel side loading logic
% - allocate page and map all LOAD segments in the ELF executable
% - fix all relocations for maps and kernel symbols
% - use the same eBPF insfrastructure
% problem where programs within the same executable share code
% - multiple programs calling the same function
% - one copy per program is ineffcient on memory
% - solution: first load the ELF executable, then associate individual programs
%   with extension entry functions in the code
There are two major differences between eBPF and \projname{} that poses unique
    challenges to the loading of \projname{} programs in the kernel.
Firstly, \projname{} is loaded as native code after compilation, of which the
    kernel does not have control on the layout.
This means the kernel need to parse and handle different sections in the
    program differently.
In contrast, eBPF is loaded as eBPF bytecode and contains only executable code.
The kernel has complete control over the generated native through the kernel
    eBPF JIT infrastructure.
Secondly, \projname{} does not have the in-kernel verifier, which is used in
    eBPF to fixup the kernel objects the program references (e.g., maps and
    helpers).
Therefore, the loading logic also needs to perform fixups needed for
    \projname{} on relocations.

We extend the \texttt{bpf} system call to support loading of \projname{}
    programs.
The system call sends the compiled ELF executable as well as the associated
    relocation information into the kernel.
The kernel first parses the ELF executable and locate all the \texttt{LOAD}
    segments in the executable.
The kernel then allocate new pages and maps the \texttt{LOAD} segments into the
    kernel address space based on the size and permissions of the segments.
With the associated relocation information, the kernel then updates the needed
    relocation entries with the absolute kernel address.
The relocations that need fixup are kernel symbols referenced by the
    \projname{} program (\S~\ref{impl:crate:symbol-resolv}) and eBPF maps
    (\S~\ref{impl:map}).
At this point, the program is considered ``loaded''.
The kernel then wrap the program into a \texttt{bpf\_prog} struct as if it is a
    JIT-ed program -- reusing the existing eBPF infrastructure for program
    management greatly reduces engineering efforts and facilitates easy
    integration with existing eBPF hook points.

One of the problem \projname{} faces is to deal with multiple programs within
    the same ELF executable.
Such programs may share common code in the same executable.
It is obviously not memory efficient if the load of each program requires
    loading and mapping of the same executable.
The soluation \projname{} uses is that it separates the steps of mapping the
    executable into kernel memory and loading of programs.
The userspace first invokes our extended \texttt{bpf} system call to map the
    executable into kernel address space and obtain a reference count to the
    mapped code (behind a file descriptor).
It then can invoke the syscall again to load the program into the kernel.
This later step is simple as it only needs to wrap the function associated with
    the \projname{} program into the \texttt{bpf\_prog} struct.
The newly created \texttt{bpf\_prog} struct takes the reference count of the
    mapped executable code so that the kernel will not clean it up before the
    programs are destroyed.
This allows multiple programs to effectively share the same executable code and
    avoid waste of memeory resources.

\subsection{Supporting eBPF maps}
\label{impl:map}
% maps are important: storage and data sharing
% supporting map is hard:
%   2 step of rewriting for the sake of easy programming and hide kernel
%     pointer
%   Not directly available in Rust
%   need to make map interface safe
%   also need seamless support as eBPF does
%
% Use a loader library:
%   define a ABI of Rust map object in memory (metadata + actual kptr) put in
%     .map section
%   loader library parse elf object and find all maps
%   use the defined ABI to read out metadata and create map via bpf syscall
%   rewrite kptr in each map in the elf object with map fd (safe because
%     kptr is 8 byte and can be treated as an int and map fd is 4 byte)
%   when loading the program, send in the updated elf object and offset of each
%     map kptr within the object
%   kernel will use the previously written fd in the kptr to retrieve the real
%     address of the map and update kptr value.
%   kptr is initialized to null, since compiler does not see the post
%     compilation fixups, it will assume the value never changes and
%     constant-propogate the map kptr, leading to incorrect program behavior
%   e.g. the map helpers always verifies the kptr is not null before invoking
%     actual kernel helper, assuming the kptr to be always null makes the map
%     helper always return error without calling into the kernel
%   solution: treat the kptr as a volatile variable and force a load before
%     each map call
%
The kernel eBPF maps provide a powerful primitive for extension programs to
    store data across program runs and to easily share data with userspace.
Therefore, such a functionality is highly desired in \projname{}.
However, supporting eBPF maps out-of-box is not trivial due to how maps defined
    in the programs are handled currently in eBPF.

eBPF allows user to define a eBPF map in the program by defining a struct that
    contains the map metadata (e.g. key/value type, number of entries) in a
    specific \texttt{.map} section.
All map operations in the program on this map is made through this struct
    defined in the program.
At program load time, libbpf parses the map metadata from the struct.
It then creates the map in the kernel through the \texttt{bpf} system call and
    obtain a file descriptor referring to the map.
Libbpf rewrites the eBPF byte code such that all references to the created map
    are updated to the value of the file descriptor.
When the program is loaded to the kernel, the eBPF verifier performs a second
    round of rewriting -- for each map file descriptor, it obtains the actual
    kernel eBPF map struct the file descriptor refers to and updates the
    references to the address of the kernel internal map struct.
This two-stage rewriting provides two desired properties: it not only prevents
    leaking of a kernel map address to userspace but also allows seamless and
    transparent interaction with the kernel maps from extension programs.
However, for \projname{}, achieving these two properties is not trivial: the
    Rust compiler cannot provide these since creating maps is out-of-scope for
    it, and at the same time the existing two-stage rewriting is specifically
    for eBPF and cannot be reused for Rust programs directly.

In order to support a safe and convenient map interface, \projname{} defines
    its own ABI for storing map metadata and implements the rewriting logic in
    its own program loader library.
In \projname{} programs, users can define a map by creating a new
    \texttt{rex\_map} object in the \texttt{.map} section through a convenience
    macro provided by the \projname{} kernel crate.
\texttt{rex\_map} is defined in the \projname{} kernel crate, which contains
    various map parameters, and a private pointer to the kernel map struct.
The struct is generic with the map type (e.g. array vs. hash), key type, and
    value type as generic parameters.
All map helpers in \projname{} are also generic functions with the same set of
    generic parameters.
They take \texttt{rex\_map} objects as arguments and internally invokes the
    kernel map helper functions with the kernel map pointer.
Doing so ensures safety of map operations -- it prevents mismatches in map
    types and key/value types.

The ABI is implemented by forcing the \texttt{rex\_map} struct to have
    C-representation, i.e., the memory layout, alignment, will be the same as
    a C struct with the same fields.
Doing so allows the \projname{} loader library to easily parse a
    \texttt{rex\_map} struct to obtain the map metadata.
Similar to libbpf, the \projname{} loader library reads and parses the ELF
    executable created by the Rust compiler.
The loader library parses and finds all maps in the \texttt{.map} section.
This is possible because the constructor of \texttt{rex\_map} is defined as
    a constant expression and therefore the \texttt{rex\_map} objects are
    initialized at compile time.
With the metadata for each map, the library creates kernel eBPF maps using the
    \texttt{bpf} system call and rewrites the kernel pointer field of each
    \texttt{rex\_map} object to the file descriptor value.
When loading the program, the loader library sends both the updated ELF
    executable and a list of offsets of the kernel map pointer field within the
    executable to the kernel.
The kernel reads the file descriptor at each offset and update it with the real
    map address referred by the file descriptor to make all map operations
    work.

During initialization, the kernel pointer field in \texttt{rex\_map} is set
    to \texttt{NULL}.
Since the \texttt{rex\_map} objects are defined as read-only and rewriting
    happens after compilation, this makes the Rust compiler incorrectly assume
    the kernel map pointer always stays \texttt{NULL}.
This in turn causes the compiler to perform constant propagation on the kernel
    pointer field when optimizations are enabled, leading to incorrect program
    behavior.
For example, the \projname{} map helpers in the \projname{} kernel crate always
    verifies that the kernel pointer is not null before invoking the kernel map
    helper functions.
By constant-propagating the \texttt{NULL} pointer value, the compiler believes
    the check always fails and makes the map helper always to return error
    without calling into the kernel helper function.
In order to solve this problem, the \projname{} kernel crate treats the kernel
    pointer as volatile and forces a load of the pointer value from memory
    every time it is used by the map helpers.

\subsection{Entry code generation}
% \begin{itemize}
%     \item LLVM pass
% \end{itemize}
To allow \projname{} extension code in Rust to be called from the kernel C
    code, an FFI entry-point function is needed to wrap around the user-defined
    extension function.
This wrapper function needs to handle certain unsafe operations, for example,
    interpreting the context argument supplied by the kernel as a Rust
    reference and perform context conversion for selected program types.
Because of this, this entry function should not be implemented by the user.
For example, interpreting an XDP context as a kernel perf-event context and
    perform the context conversion specific to perf-event would violate memory
    and type safety and could result in undefined behavior.
Therefore, \projname{} choose to automatically generate the entry point code
    during compilation of the Rust extension programs.

We implement the generation of entry code as an LLVM pass, taking the advantage
    that Rust by default uses LLVM as its code generation backend.
At the LLVM-IR stage, the entry code generation pass reads out the information
    related to the program from the program object the user defines.
This is achieved by enforcing a specific memory layout of the program object
    struct (e.g., always store the program type in the first integer field) and
    then constant-initializing the program object, which effectively implements
    an ABI between the Rust compiler front end and the LLVM middle/back end.
The pass will create a new entry function for the program with the
    user-supplied program name.
The function has the same prototype as the kernel hook point, and therefore,
    the kernel can directly invoke the function from the place the program is
    attached.
Inside the entry function, depending on the type of the program, the pass
    generates code that invokes the program-type-specific code from the
    \projname{} kernel crate
The code reinterprets the context argument supplied by the kernel into a Rust
    object, performs context conversion if needed, and eventually call into the
    user-defined extension function that is associated with the \projname{}
    program object.

% \subsection{Handle exceptional control flow}
% \begin{itemize}
%     \item kernel trampoline
% \end{itemize}

% \subsection{Stack overflow protection}
% \begin{itemize}
%     \item kernel vmapped, dedicated stack
%     \item LLVM instrumentation
% \end{itemize}
