\section{Design and Implementation}

% \subsection{Design goal}

%\begin{itemize}
%     \item Safety
%         \begin{itemize}
%             \item Same level of safety as eBPF
%             \item Memory safety
%             \item Control-flow soundness
%             \item Resource management
%             \item Program termination
%         \end{itemize}
%     \item Expressiveness
%         \begin{itemize}
%             \item Support more complicated/advanced programs
%             \item Longer programs
%             \item Unbounded loops
%         \end{itemize}
%     \item An important note: we want expressiveness w/o impairing safety (e.g.
%         allow unbounded loop while ensuring termination)
% \end{itemize}

% \subsection{Overview}
% \begin{itemize}
%     \item Brings out the Rust based approach (use Jiyuan's property-oriented
%         argument: We want these properties, and Rust happens to provide these)
%     \item Infrastructure (Need a figure similar to Fig. 5 from HotOS paper)
% \end{itemize}

\subsection{\projname{} kernel crate}
\begin{itemize}
    \item overall structure: program type, kernel binding generation, wrapper
        interface around binding.
    \item context conversion
    \item kernel helper and symbol bindings (dynamic linking scheme)
    \item kconfig-based conditional compilation
    \item Map support
\end{itemize}

The \projname{} kernel crate is responsible for supporting interactions between
    kernel and \projname{} programs.
This library can be divided into support for different program types with
    intrefaces facing the kernel and the \projname{} program.
Each of the program type is defined as a Rust struct and with helpers defined
    as its methods.
This effectively implements access control on helper functions with respect to
    program types (e.g., a tracing program should not modify socket buffers
    through networking helper functions), which is also present in eBPF.
On the side of \projname{} program, the user defines a program object
    associated with a Rust function as the extension program and can invoke
    helper functions through the program object.
For the kernel interface, we create bindings for the needed kernel definitions
Specifically, we use Rust-bindgen~\cite{bindgen} to create bindings for kernel
    structure definitions and constants from kernel header files.
For required kernel symbols (e.g., kernel helper functions), the kernel crate
    creates a stub declaration for each symbol without using Rust-bindgen.
This is because certain kernel symbols -- especially all eBPF helper
    functions --  do not have a declaration in kernel header files.
The actual definition of the kernel symbols will be resolved when the program
    is loaded into the kernel (\S~\ref{impl:crate:symbol-resolv}).
The crate also has support for maps (\S~\ref{impl:crate:map}) and other
    miscellaneous utilities for the ease of programming (e.g. wrapping return
    code in \texttt{Result} to support monadic operations in Rust).

\subsubsection{Kernel symbol resolution}
\label{impl:crate:symbol-resolv}
The \projname{} kernel crate serves as an interface for the extension programs
    to interact with the kernel.
To accomplish this, the crate will need to access kernel symbols.
For example, invoking kernel helper functions requires knowing the kernel
    address of the target helper function symbol.
These kernel symbols includes not only BPF helper functions, but also other
    global and per-CPU variables.

Because \projname{} programs are compiled in userspace, the compiler does not
    have knowledge on any of the required kernel symbols.
One simple solution is to directly passing kernel symbols and their
    corresponding addresses to userspace (e.g. through \texttt{/proc/kallsyms})
However, this is in general considered a dangerous practice as it leaks kernel
    addresses to userspace.
At the same time, this solution is not robust against kernel layout changes
    (e.g. due to kernel rebuild) -- changes of a kernel symbol address requires
    a recompilation of the \projname{} program that uses it.

Our implementation defers the kernel symbol resolution to program load time,
    i.e. when the compiled \projname{} program is sent to the kernel.
At this point, the booted kernel always knows where the symbols are located,
    even after layout changes.
At the same time, the sensitive kernel addresses do not need to be leaked to
    userspace.

\projname{} implements this kernel symbol resolution scheme the same way
    dynamic linking works in userspace.
The \projname{} kernel crate creates stub declarations for the required kernel
    symbols.
During compilation, the compiler treats all kernel symbols as external and\
    generate relocation entries for these undefined symbols.
At load time, the loader library parses the executable, compiles a list of
    kernel sybmols that require resolution with their corresponding entries in
    the global offset table (GOT), and sends the information to the kernel.
The kernel then resolves the address for each symbol via the kallsyms subsystem
    and patches the GOT entries with the resolved addresses and allows programs
    to correctly referencing these kernel symbols.

\subsubsection{Kconfig-aware conditional compilation}
% kernel uses config-based conditional compilation
% certain functionalities may not be compiled in
% we also use conditional compilation in kernel crate
% read config from build script and pass to the compilation process
The fact that the Linux kernel employs conditional compilation extensively
    based on kernel configuration values implies that certain functionalities
    used by \projname{} programs may not be compiled in.
An example of this is the ability to override the return value of a function in
    Kprobe programs.
This is only available if the \texttt{CONFIG\_BPF\_KPROBE\_OVERRIDE} is
    enabled.
The \projname{} kernel crate utilizes the conditional compilation counterpart
    in Rust.
The build script of the crate parses the configuration of the kernel for which
    the program is built and send configuration values of interest to the
    compiler.
If a functionality does not have its associated configuration set, its support
    in the kernel crate will not be present, either.

\subsubsection{Supporting eBPF maps}
\label{impl:crate:map}

\subsection{Program load and attachment}
\begin{itemize}
    \item kernel loading code and attachment
    \item relocation fixups for maps and kernel symbols
    \item libiu
\end{itemize}

\subsection{Entry code generation}
\begin{itemize}
    \item LLVM pass
\end{itemize}

\subsection{Handle exceptional control flow}
\begin{itemize}
    \item kernel trampoline
\end{itemize}

\subsection{Stack overflow protection}
\begin{itemize}
    \item kernel vmapped, dedicated stack
    \item LLVM instrumentation
\end{itemize}

\subsection{program termination}
\begin{itemize}
    \item Need work
\end{itemize}
