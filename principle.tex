\section{Principle and ideas}
\label{sec:principle}

\jinghao{\S~\ref{sec:principle}: How to make it safe}

%\begin{itemize}
%    \item goal: expressive and safe (more expressive than and at least as safe
%        as eBPF)
%    \item Current problem of eBPF: the verifier
%    \item Idea: remove the verifier and use a safe language
%    \item the language should be Turing complete and at the same time low-level
%        enough to provide safety features.
%    \item We choose Rust as the implementation language.
%    \item The use of Rust automatically provides eexpresssiveness
%    \item We then show how a safety can be achieved for kernel extensions via
%        language-based safety from Rust.
%    \item how to ensure safety (high-level discussion, no implementation
%        details)
%        \begin{itemize}
%            \item builtin memory/control/type safety
%                \begin{itemize}
%                    \item generic and const-generic functions and slices to
%                        prevent OOB access
%                    \item Safe direct packet access for XDP programs
%                    \item Retired expressiveness kernel helpers (\jinghao{probably does not belong here})
%                \end{itemize}
%            \item RAII (e.g. lock, refcnt)
%            \item exception handling and stack unwinding
%                \begin{itemize}
%                    \item Needed because Rust itself has runtime checks (e.g.
%                        array OOB access)
%                    \item handle exceptional control flow
%                    \item clean up resources to achieve RAII under exceptional
%                        circumstances
%                \end{itemize}
%            \item runtime mechanism to support properties that are
%                (fundamentally) hard to check at compile time
%                \begin{itemize}
%                    \item program termination
%                    \item stack overflow protection
%                \end{itemize}
%        \end{itemize}
%\end{itemize}

% Some small things here and there
%
% - no clone impl for objects returned by RT crate to ensure uniqueness
% - difference between userspace Rust: there are things the compiler cannot see
%   e.g., we cannot have something like Mutex::get_mut in bpf_spinlock to
%   access a value w/o lock using the single-mutable-reference rule


The goal of \projname{} is to provide enhanced usuability for kernel extensions,
    while ensuring the safety properties of the extension programs.
In particular, we aim to make \projname{} more usable than eBPF and at least
    as safe as eBPF.
As discussed in \S~\ref{sec:motivation}, the current problem of usability of
    eBPF is the large semantic gap between the programer, who works on
    high-level languages, and the verifier, which operates on compiled bytecode.
% Our insight is that both the needed expressiveness and safety can be obtained
%     from a safe programming language without the verifier.
Our insight is that by using a safe, high-level language that directly
    implements the required safety of the kernel, the semantic gap can be
    closed.
% Specifically, the language should have the following properties:
% \begin{itemize}
%     \item \textbf{Turing-complete}: This helps to satisfy the expressiveness
%         requirement.
%     \item \textbf{Safe}: The language should not be as permissive and
%         error-prone as unsafe languages like C.
%     \item \textbf{Low-level}: Being low-level helps the programs to better
%         model low-level kernel semantics and simplifies infrastructure needed
%         to support it.
% \end{itemize}

\projname{} uses Rust as the language for extension programs.
% This is because Rust happens to provide the desired properties -- its
%     language-based safety can be leveraged for safe kernel extensions without a
%     verifier.
This is because Rust provides either the desired properties directly or
    essential building blocks to ensure the safety properties.
Here, we list the important safety properties
\begin{itemize}
    \item Memory safety
    \item Type safety
    \item Safe resource management
    \item Exception-based runtime safety
    \item Stack safety
    \item Program termination
\end{itemize}

\jinghao{The runtime exception handling is not necessarily an independent one,
it actually covers some of the type safety (arrays and slices does runtime
checks that may trigger exceptions)}

We now discuss how the safety properties from Rust can be applied to the
    context of kernel extensions to provide a safe programming interface.
% While the use of Rust automatically provides expressiveness (as it is
%     Turing-complete), it does not supply the safety out-of-box, and the use of
%     Rust, especially unsafe Rust, can still exhibit undesired behaviors.
% We require all extension programs to be implemented \textit{only} in safe Rust.
% On top of that, we discuss how the safety properties from Rust can be leveraged
%     and applied to the context of kernel extensions to provide a safe
%     programming interface.

\begin{figure}
    \includegraphics[width=1.0\linewidth]{figs/overview.pdf}
    \centering
    \vspace{-10pt}
    \caption{Overview of \projname{}}
    \label{fig:rex-overview}
    \vspace{-10pt}
\end{figure}

Figure~\ref{fig:rex-overview} provides an overview of the \projname{} framework.
The extension program is written strictly in safe Rust.
The program interacts with the kernel through a program interface implemented
    by the \projname{} ``kernel crate''.
The kernel crate contains unsafe Rust code due to its role as a bridge between
    the safe extension program and the unsafe but trusted kernel code.
It also provides a custom Rust panic handler to support panic-based runtime
    safety checks in Rust.
The program links with the ``kernel crate'' at compile time and runs in a
    light-weight runtime environment implemented in the kernel, which provides
    program termination and stack unwinding support.

\subsection{Memory safety}
Generally, kernel extensions cannot access kernel memory.
However, there are frequenct cases that an extension program needs to work on a
    shared buffer of data or a specific struct and exchange data the kernel.
% These regions of memory are accessed by both the program via helper functions
%     and the kernel.
% Rust provides powerful primitives that help to validate the memory is
%     accessed correctly.
There are usually two common patterns on how the memory is accessed, differing
    in the owner of the memory:
\begin{enumerate}
    \item The memory is owned by the extension program (e.g., on-stack buffers)
        is sent to the kernel through the helper function interface.
    \item The memory is owned by the kernel (e.g., in-kernel structs) and is
        accessed from the extension program. % direct packet access, map data ptr
\end{enumerate}

In the first case, the extension program may allocate some memory on the stack
    and send it to the kernel for processing (e.g., asking kernel to fill a
    stack buffer with some data).
An unsafe memory access, for example, an out-of-bounds write to the on-stack
    buffer, could result in corruptions of stack data and possibly trigger a
    kernel oops if the return address is overwritten to an non-presenting page.

For eBPF, the verifier validates the memory region with the size to make sure
    that both the kernel and the program do not make erroneous accesses.
For the memory buffers sent to the kernel through the helper function interface,
    the corresponding size is also sent as an argument to the helper.
The verifier, at program load time, checks to ensure that the size is exactly
    that of the memory buffer.
Then, at runtime, the kernel can operate on the buffer with the knowledge of
    its bounds, thereby avoid unsafe memory accesses.

In \projname{}, the strict type system of Rust already protects program from
    making an unsafe access.
\projname{} leverages the generic programming feature of Rust to ensure the
    size sent through the helper function interface is always valid.
% In order to make sure that the size sent to the kernel is always correct, which
%     is vital for the correctness of memory access from the kernel, we leverage
%     the generic programming support of Rust.
For the kernel helper function that falls to the category of taking in a
    program-supplied pointer and size, the \projname{} kernel crate creates an
    adaptor interface that parametrize the type of the pointer as a generic
    type parameter.
The interface queries the size of the generic type from the compiler
    and invoke the kernel interface with this size as the argument.
Since Rust employs monomorphization~\cite{rustc-monomorphize}, the concrete
    type and its size is resolved at compile time, adding no runtime overhead.
In this way, the size is guarranteed to match the type statically and the
    kernel will never make an out-of-bound access.
This can work for not only the scalar types, but for array types as well: Rust
    also supports ``const generics'' that allows a constant to be used as a
    generic parameter, which can be used to encode length of arrays.

In the second case, the kernel may provide the user program a pointer to
    kernel memory to perform direct access (e.g., access through eBPF map value
    pointers and packet pointers).
The user programs must not make an out-of-bound memory access for this
    kernel-owned region of memory, as doing so risks corrupting kernel data.

For accesses on pointers with a static size, e.g. map value pointers since maps
    store the size of its value types, the verifier can independently verify
    the validity of the check.
For pointers with out a static size like packet data pointers, the verifier
    enforces user programs to explicitly check for memory
    boundaries and to not make an out-of-bound access.

In \projname{}, the former case is handled through the Rust type system, as the
    kernel map interface of \projname{} encodes the key and value types through
    generics, and therefore forces the pointer to be a safe Rust reference of
    the particular type.
Pointers referring to a memory region without a static size are generally
    dynamic-sized buffers.
The \projname{} kernel crate abstracts such pointers into a Rust \textit{slice}
    with dynamic size.
Rust slice provides runtime bounds checks (\S~\ref{principle:eh}), which allows
    the check to happen automatically without explicit handling from the
    extension program.

\subsection{Extended type safety}
Kernel extensions may contain certain paradigms that are beyond the safe
    type system of Rust.
One challenge is to allow extension programs to safely reinterpret the stream
    of bytes into useful data.
Such cases are notably found in networking use cases, where a program may need
    to extract the ethernet header from the bytes buffer in the packet.
Safety of these transformations are hard because they inevitablly involves
    unsafe type casting.
% For example, a XDP program using direct packet access might need to extract
%     the ethernet header information from the bytes in the packet.

Currently, eBPF allows the program to freely interpret the packet data into
    other data types via pointer casting.
The verifier checks the casting and ensures that 1. the program does not make a
    pointer from scalar values and 2. the new type fits within the memory
    boundaries.

\projname{} agrees with the verifier that as long as the above two properties
    holds, the reinterpret cast (dubbed ``transmute'' in Rust) is safe to
    perform.
It therefore extends the type safety of Rust to cover such cases.
% In the case of Rust, the reinterpret cast (dubbed ``transmute'' in Rust) is an
%     unsafe operation, particularly because Rust does not prevent making
%     pointers from scalar values.
To allow extension programs to still safely reinterpret the bytes into useful
    data types, we first define a group of primitive scalar types that are
    considered safe as target for casting.
\projname{} requires target type of casting to be of either the safe types or a
    structure type in which all the members are of the safe types.
The safe types are specified by implementing the \texttt{Rex::SafeTransmute}
    trait, which is only implementable by .

We use the ``proc-macro'' feature of Rust to enforce this constraint at compile
    time.
Like conventional C macros, proc-macros performs transformation on the program,
    albeit on the abstract syntax tree level.
Our proc-macro, when applied on a structure type, generates code that tries
    to treat each field of the structure as an instance of
    \texttt{Rex::SafeTransmute} followed by the actual transmute operation to
    perform the unsafe cast.
If one of field in the structure does not implement \texttt{Rex::SafeTransmute},
    the Rust compiler will issue a compile error.
At the same time, if the program tries to directly transmute the bytes into a
    structure without using the proc-macro, the compiler will also emit an
    error because tranmute belongs to unsafe Rust, which we \projname{} as
    forbidden in extension programs.
Since proc-macro transformations happen after the linting of unsafe operations,
    the transmute code generated by the proc-macro will not be rejected and,
    therefore, allows programs to perform transmutes in a safe, and controlled
    way.

\subsection{Safely manage resources}
Executing in the kernel, extension programs must also acquire and release
    resources properly.
Some kernel helper functions returns kernel resources that requires
    explicit release after use through a corresponding helper function call.
Failing to do so will result in leakage of kernel resources such as reference
    counts and acquired spinlocks.
% In eBPF, some kernel helper functions returns kernel resources that requires
%     explicit release after use (e.g., reference counts of kernel objects,
%     locks).
In these situations, the eBPF verifier checks and ensures that the resource is
    released on all possible code paths to prevent leaking kernel resources.

In \projname{}, the resource-acquisition-is-initialization (RAII) pattern of
    Rust can be used to create an abstraction around kernel resources that
    extension programs need.
For example, when the program obtains a spin lock from the kernel, our Rust
    abstraction layer constructs and returns a lock guard.
The lock guard implements the RAII semantics through the \texttt{drop} trait in
    Rust, which defines the operation to perform when an object is destroyed.
In the case of lock guard, its \texttt{drop} handler releases the lock.
The program does not need to explicitly release the lock or drop the lock
    guard, instead, the compile inserts an implicit \texttt{drop} at the end of
    the current scope. This effetively releases the lock when the lock guard
    goes out of scope.

\subsection{Runtime exception handling}
\label{principle:eh}
While the compiler contributes a lot to the safety of Rust, many safety checks
    happen at runtime in the form of exceptions (i.e., Rust panics).
In userspace, Rust uses the Itanium exception handling ABI.
When an exception is triggered, the control flow is transferred to the Rust
    panic handler in its standard library, which in turn calls into the unwind
    library to perform stack unwinding and resource cleanups for each stack
    frame.
However, the Itanium ABI is not suitable for kernel extensions, making
    exception handling a challenge in extension programs:
\begin{itemize}
    \item The Itanium ABI-based exception handling is too complicated, as the
        userspace unwind libraries are not direcly usable.
    \item Failures during unwinding, which are permissible in userspace, cannot
        be tolerated in kernel space, as incomplete cleanup means leaking
        kernel resources.
    \item ABI-based unwinding typically requires dynamic allocation, which
        creates challenges for extensions in interrupt contexts, in which an
        allocator may not be available~\cite{bpf-mempool-lwn}. \jinghao{I'm
        thinking about removing this one since bpf now has an allocator.}
    \item Unwinding generally executes destructors for all existing objects on
        the stack, but executing untrusted, user-defined destructors (via the
        \texttt{\small Drop} trait in Rust) is not safe.
\end{itemize}

\begin{figure}
	\includegraphics[width=0.8\linewidth]{figs/EH.png}
	\centering
	\vspace{-10pt}
	\caption{Overview of exception handling control flow}
	\label{fig:eh-overview}
	\vspace{-10pt}
\end{figure}

Our exception handling framework consists of two components: 1) graceful exit
    upon exceptions that resets the current context and 2) resource cleanup to
    ensure release of kernel resources like reference counts and locks.
To support a graceful exit from an exception, we implemented a small runtime
    (as shown in Figure~\ref{fig:eh-overview}) in the kernel that contains a
    program dispatcher, a panic handler, and a landingpad function.
The dispatcher function takes the same duty of executing the extension program
    as the existing eBPF dispatcher.
It saves the old stack and framepointer of the current context into per-CPU
    memory before switching to the dedicated program stack
    (\S~\ref{principle:stack}) and calling into the program.
If the program executes normally without triggering an exception, it would just
    return to the dispatcher, which switches the stack back.
Under exceptional cases where a Rust panic is triggered, the panic handler will
    transfer the control flow to the landingpad function to print debug
    information related to the exception (e.g., exception message) to the
    kernel ring buffer.
Then, the landingpad function redirects the control flow to a pre-defined label
    in the middle of the dispatcher function, where it restores the old value
    of the stack and frame pointer from the per-CPU storage.
This effectively unwinds the stack and resets the context as if the extension
    program returned successfully.
% We implement the program dispatcher function with panic handling in the kernel
%     in 28 lines of x86 assembly code.

For resource cleanup, light-weight mechanisms can be effective.
Our insight for resource cleanup is that the extension program can only obtain
    resources by explicitly issuing helper function calls and therefore only
    these resources needs to be released.
For these helper function calls, we record the allocated kernel resource during
    execution into a per-CPU buffer.
Currently, the size of the buffer can support a program to allocate at most 64
    instances of kernel resources during a single run.
Upon a panic, the panic handler will take the responsiblility to correctly
    handle the release of kernel resources, which involves traversing the
    per-CPU buffer and performs cleanup for each of the recorded resources.

\jinghao{It seems that nesting should be put somewhere, due to the fact that
these per-CPU tricks depend on no-nesting.}

We implement the cleanup code as part of the \projname{} kernel crate, as it
    is the core component resiponsible for coordinating helper function calls
    that obtain kernel resources.
In this way, the resource cleanup is completely transparent to the extension
    programs, adding no additional programming burden like the Itanium ABI.
The other reason for implementing cleanup mechanism inside the kernel crate is
    safety, because such code maybe called upon panic, it must not trigger yet
    another Rust panic and causes panic handling to fail.
Therefore, \projname{} does not execute user-supplied \texttt{drop} handlers
    upon panic, as they are not guarranteed to be safe during panic handling
    context and programs cannot allocate resources without helper function
    calls.

\subsection{Safe guard the kernel stack}
\label{principle:stack}
One unique safety requirement the kernel extension programs are facing is the
    usage of kernel stack.
Unlike the userspace programs, where the stack grows on demand and has a large
    maximum size,
    the stack in kernel space is fix-sized (4 pages on x86-64) and limited.
Overflowing the kernel stack may result in memory corruptions or kernel panics.

The eBPF verifier handles stack safety by keeping track of the stack size
    throughout its symbolic execution process.
However, the verification of the stack usage does not always yield the correct
    result -- in particular, the verifier is shown to fail to track stack usage
    across the indirect tail calls~\cite{ebpf-stackoverflow}.

Our observation is that the enforcement of stack safety can be easily performed
    at compile time if the extension program does not have indirect or
    recursive calls, and conversely, it is easier to perform such check at
    runtime when the program does employ indirect or recursive calls.
\projname{} therefore takes a hybrid approach in ensuring stack safety that
    utilizes static checks for programs without indirect or recursive calls,
    and dynamic, runtime checks for programs make use of these function calls.
For each program being compiled, the \projname{}-specific pass in the compiler
    will check whether it involves indirect or recursive calls.
When the extension program contains only direct, non-recursive function calls,
    its total stack usage can be calculated by traversing its static callgraph
    and sum up the size of each call frame.
If the total stack usage of the program exceeds total amount of stack
    available, the \projname{} compiler pass will generate an error and reject
    the program.

On the other hand, programs with indirect or recursive calls are hard to check
    for stack usage statically, as is the case in the eBPF verifier.
In these cases, \projname{} performs runtime checks to limit the stack usage of
    programs.
The \projname{} compiler pass first ensures each function in the program takes
    less than one page (4K) of stack.
Then, before each function call in the extension program, the \projname{}
    compiler pass inserts a call to \texttt{\_\_rex\_check\_stack} function.
\texttt{\_\_rex\_check\_stack} is provided by the kernel crate and checks the
    current stack depth of the program, if the stack usage exceeds the
    threshold, it will trigger a Rust panic and effectively terminate the
    program (\S~\ref{principle:eh}).

In order for the \texttt{\_\_rex\_check\_stack} function to have more control
    on the stack usage of the program and also support programs with slightly
    large stack usage, \projname{} implements a dedicated kernel stack for the
    extension programs.
The dedicated kernel stacks are allocated and virtually mapped per-CPU during
    kernel boot time with the same size as the kernel IRQ and task stacks.
In the dispatcher function (\S~\ref{principle:eh}), before calling into the
    \projname{} program, the stack and frame pointers of the current context
    are saved.
The dispatcher function then sets the stack and frame pointer registers to the
    top of the dedicated stack and invokes the program.
Upon program exit, the original stack and frame pointers are restored, no
    matter whether a exception is triggered during program execution.

\projname{} defines the stack usage threshold to be two pages less than the
    total stack available.
This design choice is based on two considerations.
First, kernel helper functions are not visible at program compile time but they
    also account for stack usage during program execution.
Leaving extra spaces accomodates kernel helper functions and we believe two
    pages of stack is a reasonable limit for kernel helper functions.
Second, since the stack usage of each function in the program is limited to
    1 page of stack, in the worse case the remaining stack space is at least
    one page when \texttt{\_\_rex\_check\_stack} triggers a Rust panic.
This worse case guarrantee leaves enough space for the panic handling and stack
    unwinding routines.
Such a dynamic mechanism allows \projname{} to achieve better stack-safety than
    eBPF, which only relies on static verification.

\subsection{Program termination}
To safely terminate a BPF execution, we need to ensure the following :

\begin{itemize}
	\item A BPF program should never be terminated while executing a helper function
		or the panic handler.
		This is neccesary to ensure kernel objects acquired during a helper call
		are freed.
	\item Any kernel objects allocated within a BPF program should be released
		before termination.
\end{itemize}

\projname{} supports dynamic program termination through an extended BPF syscall
interface.
The termination logic uses the Linux kernel's Inter-Process Interrupt (IPI) mechanism
to raise an interrupt on the target BPF program's CPU.
The raised interrupt handler first detaches the BPF program from its hookpoint to prevent
further invocation.
The handler then changes the saved registers(in the interrupt stack) from the BPF context
 to point to the \projname{} panic handler(section \ref{principle:eh}).
The CPU returns the execution to the panic handler which performs the cleanup of
any kernel objects that were live at the time of termination.
To address the case when the target BPF program could be inside a helper/panic handler,
we use a per-cpu tristate flag which can only have states denoting : (i) within BPF,
(ii) within helper/panic or (iii) termination requested.
Every helper invocation precedes with changing the state from state (i) to state (ii).
During the termination interrupt handler, if the flag is at state (ii),
the termination handler just modifies it to state (iii) which indicates an exiting
helper call to panic.
This mechanism is used to defer a panic invocation until the end of a helper execution.

Note that we are assuming the availability of a free CPU, which can be used to invoke the
IPI.
While this solution won't work for uniprocessor systems, we find this limitation
acceptable due to the current cloud infrastructure predominantly being SMP.